#ifndef WORLDDATA_H
#define WORLDDATA_H
/// The below code was generated by
/// the Arduventure World Editor
/// created by Gavin Atkin 2016-2017
/// and rearranged + optimized by JO3RI

#include "globals.h"
#include "enemies.h"

#define TILE_FLOOR                    8
#define TILE_STAIRS                   9
#define TILE_ROCK                     31
#define TILE_WALL                     47
#define TILE_BLACK                    55
#define TILE_SIGN                     56
#define TILE_CLOSED_CHEST             57
#define TILE_OPENED_CHEST             58

byte getRegion(byte chunk_pos_x, byte chunk_pos_y)
{
  for (byte i = 0; i < TOTAL_REGIONS; i++)
  {
    Point chunk_pos = { .x = chunk_pos_x, .y = chunk_pos_y};
    Rect reg = {.x = pgm_read_byte(regions + i * 4), .y = pgm_read_byte(regions + 1 + i * 4),
                .width = pgm_read_byte(regions + 2 + i * 4), .height = pgm_read_byte(regions + 3 + i * 4)
               };
    if (arduboy.collide(chunk_pos, reg)) return i;
  }
  return REGION_FOREST;
}

void checkRegion()
{
  player.currentRegion = getRegion(playerReducedX, playerReducedY);
  changeSong(player.currentRegion);
}

bool getChunkBit(byte chunk_x, byte chunk_y)
{
  //if (chunk_x < 0 || chunk_x >= LEVEL_CHUNK_W || chunk_y < 0 || chunk_y >= LEVEL_CHUNK_H) return 1;
  //if (chunk_x >= LEVEL_CHUNK_W || chunk_y >= LEVEL_CHUNK_H) return 1;

  byte x = chunk_x / 8;           // 8 is number of chunks per byte
  byte y = chunk_y * 4;           // 4 is number of bytes per row
  byte i = chunk_x % 8;

  byte b = (pgm_read_byte(solid_map + x + y) & _BV(i));
  return (b > 0);
}


// getChunk
// Returns a value greater than 127 if the chunk was specifically placed.
// If the chunk is part of a region the returned value will be
// less than 128.
// To get the actual chunk value of a specific chunk, AND (&) the returned
// chunk with 0x7F (B01111111)
byte getChunk(byte chunk_pos_x, byte chunk_pos_y)
{
  // specific chunks
  switch (chunk_pos_x + chunk_pos_y * 32)
  {
    case 59:        // House chunk_x:          27 chunk_y:  1
    case 84:        // House chunk_x:          20 chunk_y:  2
    case 253:       // House chunk_x:          29 chunk_y:  7
    case 340:       // House chunk_x:          20 chunk_y: 10
    case 520:       // House chunk_x:           8 chunk_y: 16
    case 802:       // House chunk_x:           2 chunk_y: 25
    case 843:       // House chunk_x:          11 chunk_y: 26
      return 162;   // chunk 34 + 128
      break;
    case 171:       // Big Tree chunk_x:       11 chunk_y:  5
    case 180:       // Big Tree chunk_x:       20 chunk_y:  5
    case 192:       // Big Tree chunk_x:        0 chunk_y:  6
    case 312:       // Big Tree chunk_x:       24 chunk_y:  9
    case 353:       // Big Tree chunk_x:        1 chunk_y: 11
    case 368:       // Big Tree chunk_x:       16 chunk_y: 11
    case 394:       // Big Tree chunk_x:       10 chunk_y: 12
    case 485:       // Big Tree chunk_x:        5 chunk_y: 15
    case 493:       // Big Tree chunk_x:       13 chunk_y: 15
    case 515:       // Big Tree chunk_x:        3 chunk_y: 16
    case 562:       // Big Tree chunk_x:       18 chunk_y: 17
    case 605:       // Big Tree chunk_x:       29 chunk_y: 18
    case 627:       // Big Tree chunk_x:       19 chunk_y: 19
    case 631:       // Big Tree chunk_x:       23 chunk_y: 19
    case 716:       // Big Tree chunk_x:       12 chunk_y: 22
    case 737:       // Big Tree chunk_x:        1 chunk_y: 23
    case 776:       // Big Tree chunk_x:        8 chunk_y: 24
    case 873:       // Big Tree chunk_x:        9 chunk_y: 27
    case 881:       // Big Tree chunk_x:       17 chunk_y: 27
    case 910:       // Big Tree chunk_x:       14 chunk_y: 28
      return 170;   // chunk 42 + 128
      break;
    case 6:         // Shop chunk_x:            6 chunk_y:  0
    case 42:        // Shop chunk_x:           10 chunk_y:  1
    case 379:       // Shop chunk_x:           27 chunk_y: 11
    case 709:       // Shop chunk_x:            5 chunk_y: 22
    case 754:       // Shop chunk_x:           18 chunk_y: 23
      return 171;   // chunk 43 + 128
      break;
    case 61:        // Battle cave chunk_x:    29 chunk_y:  1
    case 33:        // Battle cave chunk_x:     1 chunk_y:  1
    case 570:       // Battle cave chunk_x:    26 chunk_y: 17
    case 718:       // Battle cave chunk_x:    14 chunk_y: 22
      return 172;   // chunk 44 + 128
      break;
    case 209:       // Inn chunk_x:            17 chunk_y:  6
    case 43:        // Inn chunk_x:            11 chunk_y:  1
    case 513:       // Inn chunk_x:             1 chunk_y: 16
    case 756:       // Inn chunk_x:            20 chunk_y: 23
      return 173;   // chunk 45 + 128
      break;
    case 801:       // Your House chunk_x:      1 chunk_y: 25
      return 174;   // chunk 46 + 128
      break;
    case 1011:      // interior Inn 2 chunk_x: 11 chunk_y: 31
      return 167;   // chunk 39 + 128
      break;
    case 655:       // FT0010 chunk_x:         15 chunk_y: 20
      return 146;   // chunk 18 + 128
      break;
  }


  // regions
  //Point chunk_pos = { .x = chunk_pos_x, .y = chunk_pos_y };
  switch (getRegion(chunk_pos_x, chunk_pos_y))
  {
    case REGION_FIELDS:
    case REGION_SWAMP:
    case REGION_FOREST:
    case REGION_YOUR_GARDEN:
      if (getChunkBit(chunk_pos_x, chunk_pos_y)) return 31;
      else
      {
        byte b = 0;
        b |= getChunkBit(chunk_pos_x + 1, chunk_pos_y);
        b |= getChunkBit(chunk_pos_x, chunk_pos_y - 1) << 1;
        b |= getChunkBit(chunk_pos_x - 1, chunk_pos_y) << 2;
        b |= getChunkBit(chunk_pos_x, chunk_pos_y + 1) << 3;

        return b + 16;
      }
      break;
    case REGION_CANYONS:
      if (getChunkBit(chunk_pos_x, chunk_pos_y)) return 15;
      else
      {
        byte b = 0;
        b |= getChunkBit(chunk_pos_x + 1, chunk_pos_y);
        b |= getChunkBit(chunk_pos_x, chunk_pos_y - 1) << 1;
        b |= getChunkBit(chunk_pos_x - 1, chunk_pos_y) << 2;
        b |= getChunkBit(chunk_pos_x, chunk_pos_y + 1) << 3;
        return b;
      }
      break;

    case REGION_FOREST_CANYON:
      if (!getChunkBit(chunk_pos_x, chunk_pos_y)) return 32;
      else return 31;
      break;
    case REGION_SWAMP_FOREST:
    case REGION_FIELDS_SWAMP:
    case REGION_FIELDS_CANYONS:
      if (!getChunkBit(chunk_pos_x, chunk_pos_y)) return (21 + (5 * (getRegion(chunk_pos_x, chunk_pos_y) - REGION_SWAMP_FOREST)));
      else return 31;
      break;

    case REGION_SWAMP_ISLAND_ONE:
    case REGION_SWAMP_ISLAND_TWO:
      if (!getChunkBit(chunk_pos_x, chunk_pos_y)) return 15;
      else return 34;
      break;

    case REGION_LONG_ROAD:
      if (!getChunkBit(chunk_pos_x, chunk_pos_y)) return 26;
      else return 31;
      break;
    case REGION_APPLE_FARM:
      if (!getChunkBit(chunk_pos_x, chunk_pos_y)) return 35;
      else return 34;
      break;
    case REGION_HOUSE_INTERIOR:
    case REGION_INN_INTERIOR:
    case REGION_YOUR_INTERIOR:
      if (!getChunkBit(chunk_pos_x, chunk_pos_y)) return (36 + (getRegion(chunk_pos_x, chunk_pos_y) - REGION_HOUSE_INTERIOR));
      else return 47;
      break;

    case REGION_SHOP_INTERIOR:
      if (!getChunkBit(chunk_pos_x, chunk_pos_y)) return 39;
      else return 48;
      break;

    case REGION_TREE_INTERIOR:
    case REGION_CAVE_INTERIOR:
      if (!getChunkBit(chunk_pos_x, chunk_pos_y)) return (40 + (getRegion(chunk_pos_x, chunk_pos_y)) - REGION_TREE_INTERIOR);
      else return 33;
      break;
    case REGION_ALL_BLACK:
      if (!getChunkBit(chunk_pos_x, chunk_pos_y)) return 33;
      else return 33;
      break;
  }
  return 0; // default chunk
}


byte getTileID(uint16_t world_pos_x, uint16_t world_pos_y)
{
  if (world_pos_x > 3056 || world_pos_y > 3136) return TILE_ROCK;
  switch (((world_pos_x >> 4) + (world_pos_y >> 4) * 192))
  {
    case 1625:                                                                                     // 89 + (8 * 192)
    case 18422:                                                                                    // 182 + (95 * 192)
    case 23901:                                                                                    // 93 + (124 * 192)
    case 30155:                                                                                    // 11 + (157 * 192)
    //case 36189:                                                                                    // 93 + (188 * 192) battle cave
      return TILE_SIGN;
      break;
    case 23709:                                                                                    // 93 + (123 * 192) FIELDS - SWAMP
      if (!bitRead(player.gameTriggers[3], 0)) return TILE_ROCK;                                   // AMULET OF WATER NOT USED
      else break;
    case 18423:                                                                                    // 183 + (95 * 192) SWAMP - FOREST
      if (!bitRead(player.gameTriggers[3], 1)) return TILE_ROCK;                                   // AMULET OF LEAFS NOT USED
      else break;
    case 1817:                                                                                     // 89 + (9 * 192) FOREST - CANYONS
      if (!bitRead(player.gameTriggers[3], 2)) return TILE_ROCK;                                   // AMULET OF FIRE NOT USED
      else break;
    case 5145:                                                                                     // 153 + (26 * 192) CHEST IN FORREST MIDDLE
      if (bitRead(player.gameTriggers[3], 6)) return TILE_OPENED_CHEST;                            // chunk: 25, 4: 29 : 100
      else return TILE_CLOSED_CHEST;
      break;
    case 18963:                                                                                    // 147 + (98 * 192) CHEST IN SWAMP NORTH
      if (bitRead(player.gameTriggers[3], 5)) return TILE_OPENED_CHEST;                            // chunk: 24, 16: 40 : 384
      else return TILE_CLOSED_CHEST;
      break;
    case 17731:                                                                                    // 67 + (92 * 192) CHEST IN FIELDS
      if (bitRead(player.gameTriggers[3], 4)) return TILE_OPENED_CHEST;                            // chunk: 1, 20: 21 : 20
      else return TILE_CLOSED_CHEST;
      break;
    case 3909:                                                                                     // 69 + (20 * 192) CHEST IN NORTH CANYONS
      if (bitRead(player.gameTriggers[3], 7)) return TILE_OPENED_CHEST;                            // chunk: 3, 2: 5 : 6
      else return TILE_CLOSED_CHEST;
      break;
    case 34891:                                                                                    // 139 + (181 * 192) CHEST IN THE HOUSE
      if (bitRead(player.gameTriggers[2], 4)) return TILE_OPENED_CHEST;                            // chunk: 23, 30: 983
      else return TILE_CLOSED_CHEST;
      break;

    /*case 36188:
      //if (bitRead(player.bossActiveAlive, player.lastDoor - 28)) return TILE_OPENED_CHEST;         // 92 + (188 * 192) Boss cave chest
      //else return TILE_CLOSED_CHEST;
      if (!bitRead(player.bossActiveAlive, player.lastDoor - 28)) return TILE_CLOSED_CHEST;
      break;*/

    case 36140:                                                                                    // 44 + (188 * 192) cave
      if (bitRead(player.gameTriggers[player.lastDoor / 8], player.lastDoor % 8)) return TILE_OPENED_CHEST;
      else return TILE_CLOSED_CHEST;

  }

  byte chunk = getChunk(world_pos_x / 96, world_pos_y / 96);
  byte tile_pos_x = (world_pos_x % 96) >> 4;
  byte tile_pos_y = (world_pos_y % 96) >> 4;
  byte tile;
  byte chunkNumber = chunk & 0x7F;
  if (chunkNumber < 15) tile = pgm_read_byte(chunks + (chunkNumber * 36) + (tile_pos_x) + (tile_pos_y) * 6);
  else if (chunkNumber < 32)
  {
    if (chunkNumber < 24) tile = pgm_read_byte(chunks + (chunkNumber * 36) + (tile_pos_x) + (tile_pos_y) * 6) & 0x0F;
    else tile = (pgm_read_byte(chunks + ((chunkNumber - 8) * 36) + (tile_pos_x) + (tile_pos_y) * 6)) >> 4;
    if (tile > 7) tile += 24;
  }
  else
  {
    chunkNumber -= 8;
    tile = pgm_read_byte(chunks + (chunkNumber * 36) + (tile_pos_x) + (tile_pos_y) * 6);
  }
  if (chunk < 127)
  {
    switch (getRegion(world_pos_x / 96, world_pos_y / 96))
    {
        break;
      case REGION_FIELDS:
      case REGION_YOUR_GARDEN:
        if (tile > 30) tile = 32;
        else if (tile == 2) tile = 0;
        else if (tile == 3 || tile == 4) tile = 5;
        else if (tile == 7) tile = 2;
        break;
      case REGION_SWAMP:
        if (tile > 30) tile = 14;
        else if (tile == 0) tile = 12;
        else if (tile == 3) tile = 5;
        else if (tile == 1 || tile == 2 || tile == 4 || tile == 7) tile = 10;
        break;
    }
  }

  switch (tile)
  {
    case 10:
    case 12:
    case 14:
      tile += frameBoolean;
      break;
    case 11:
    case 13:
    case 15:
      tile -= frameBoolean;
      break;
  }

  return tile;
}



bool getSolid(uint16_t world_x, uint16_t world_y)
{
  return (getTileID(world_x, world_y) >= 14);
}



void drawTiles()
{
  //for (int x = 0; x <= 128; x += 16)
  for (byte x = 128; x <= 128; x -= 16)
  {
    //for (int y = 0; y <= 64; y += 16)
    for (byte y = 64; y <= 64; y -= 16)
    {
      byte tile = getTileID(camX + x, camY + y);
      sprites.drawOverwrite((((camX >> 4) << 4) + x) - camX, (((camY >> 4) << 4) + y) - camY, tileSheet, tile);
    }
  }
}


void checkDoors()
{
  if (!(playerDirection & 0B00000001)) //WALKING NORTH OR SOUTH
  {
    Point p =
    {
      .x = player.x,
      .y = player.y,
    };

    for (byte i = 0; i < TOTAL_DOORS; i++)
    {
      Rect door =
      {
        .x = (16 * pgm_read_byte(&doors[i * 2])) - 3,
        .y = 16 * pgm_read_byte(&doors[(i * 2) + 1 ]),
        .width = 10,
        .height = 10
      };

      if (arduboy.collide(p, door))
      {
        if (playerDirection == FACING_NORTH) player.lastDoor = i;
        gameState = WALKING_THROUGH_DOOR;
        return;
      }
    }
  }
}


#endif
